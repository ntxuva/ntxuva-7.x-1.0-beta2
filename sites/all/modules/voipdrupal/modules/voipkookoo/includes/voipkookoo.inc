<?php
// $id$

/**
 * @file
 * Implementation of KooKoo-related functionality
 */

/**
 * Internal functions
 */

/*
 * Process incoming requests and responses from KooKoo
 *
 * @param string $kookoo_action set to the action to be executed.
 *   It can assume any of the following values:
 *   - process_conference, to handle responses to conference call requests
 *   - process_inbound_calls, to handle incoming calls
 *   - process_inbound_text, to handle incoming text
 *   - process_outbound_calls, to handle the response to outgoing call requests
 *   - process_dial, to handle the response to the "dial" script command
 *   - process_get_input, to handle responses to "get input" script commands
 *   - process_hangup, to handle call termination
 *   - process_record, process_record_mp3 and process_empty_recording, to handle
 *     responses to 'record' script commands
 *   - process_wait, to continue after wait command
 *   - process_send_sms, to handle responses to 'send sms' script commands
 *   - process_sms_callback, to handle final responses to 'send sms'.
 *
 * @param string $cid with the cid of the call
 *
 * @return void
 */
function _voipkookoo_call_handler($kookoo_action = NULL, $cid = NULL) {
  if(!$kookoo_action) {
    //Only outbound calls/sms have kookoo_action in url, otherwise retrieve from event
    $kookoo_action = _voipkookoo_event_to_actions($_REQUEST['event']);
  }

  if (voip_debug()) {
    $msg = "in voipkookoo_call_handler() with kookoo_action: $kookoo_action, cid: $cid, and _REQUEST: " . print_r($_REQUEST, TRUE);
    $vars = array();
    watchdog('voipkookoo', $msg, $vars, WATCHDOG_INFO);
  }
  //@todo: validate $_REQUEST['AccountSid'] to avoid hack attempts
  /*$server = VoipServer::getServer('kookoo');
  $server_config = $server->getConfig();
  $account_sid = $server_config['voipkookoo_account_sid'];
  $incoming_sid = $_REQUEST['AccountSid'];
  if ($account_sid != $incoming_sid) {
    $msg = '_voip_kookoo_call_handler called with invalid AccountSid: @sid';
    $params = array('@sid' => $incoming_sid);
    watchdog('voipkookoo', $msg, $params, WATCHDOG_WARNING);
    return FALSE; // TODO: should we return an error response to the server?
  }*/

  // determine channel, network, to and from attributes
  if ($kookoo_action == 'process_inbound_text'
    || $kookoo_action == 'process_sms_framework') {
    $channel = 'text';
    $network = 'sms';
    $from = $_REQUEST['cid'];
    //there is no to field in Kookoo, but we might have it if from SMS framework
    //otherwise use KOOKOO SMS NUMBER
    $to = isset($_REQUEST['To']) ? $_REQUEST['To'] : KOOKOO_SMS_NUMBER;
  }
  else {
    $channel = 'voice';
    $network = 'voip';
    $from = isset($_REQUEST['cid']) ? $_REQUEST['cid'] : $_REQUEST['cid_e164'] ;
    $to = $_REQUEST['called_number'];
  }

  // load session and cid based on request parameters

  // 'process_hangup' for incoming calls does not come with a $cid
  if (/*($kookoo_action == 'process_hangup') && */ !$cid) {
    $call_id = $_REQUEST['sid'];
    $cid = VoipCall::getCidFromCallId($call_id);
  }

  if ($cid) {
    $voip_session = VoipSession::getSessionByCid($cid);
  }
  else {
    $voip_session = VoipSession::getSessionByNumber($from, $to);
    if ($voip_session) {
      $cid = $voip_session->getCid();
    }
  }
  if (!$voip_session) {
    $voip_session = new VoipSession();
    $voip_session->setOriginNumber($from);
    $voip_session->setDestinationNumber($to);
  }

  // load the already existing call object, if any
  if ($cid) {
    $call = VoipCall::load($cid);
    // if the call is already hang up, ignore everything
    // Note: This happens whenever a call is hang up in the middle of a recording.
    // In that case, KooKoo sends a notification both as part of the record
    // response as well as via a hangup request
    $is_hangup = $call->isHangup();
    if($is_hangup){
      if (voip_debug()) {
        $msg = "Call with cid: $cid is already hang up.";
        $vars = array();
        watchdog('voipkookoo', $msg, $vars, WATCHDOG_INFO);
      }
      return;
    }
  }
  else {
    $call = new VoipCall();
  }

  // handle incoming call and text requests
  if ($kookoo_action == 'process_inbound_calls') {
    $call_sid = $_REQUEST['sid']; // A unique identifier for this call, generated by KooKoo.
    $call->setCallId($call_sid);
    $call->setSource('kookoo');
    $dir_tmp = (isset($_REQUEST['outbound_sid']))
                         ? VoipCall::OUTBOUND_DIAL
                         : VoipCall::INBOUND;
    $call->setDirection($dir_tmp);
    $call->setAnsweredBy(VoipCall::ANSWERED_DRUPAL);
    $call->setCallStatus(VoipCall::RINGING);
    $call->setStartTime(REQUEST_TIME);
	  $call->setCallerNumber($from);
    $call->setDestNumber($to);
    $call->setCallChannel($channel);
    $call->setCallNetwork($network);
  }
  else if ($kookoo_action == 'process_inbound_text'
    || $kookoo_action == 'process_sms_framework') {
    $call_sid = $_REQUEST['sid']; // unique identifier of the text, 34 char
    $call->setCallId($call_sid);
    $call->setSource('kookoo');
    $dir_tmp = VoipCall::INBOUND;
    $call->setDirection($dir_tmp);
    $call->setAnsweredBy(VoipCall::ANSWERED_DRUPAL);
    $call->setCallStatus(VoipCall::IN_PROGRESS);
    $call->setStartTime(REQUEST_TIME);

    $call->setCallerNumber($from);
    $call->setDestNumber($to);
    $call->setCallChannel($channel);
    $call->setCallNetwork($network);
    if($kookoo_action == 'process_sms_framework') {
      $call->setCallOrigin('smsframework');
    }
  }
  else {
    // handle ongoing calls
    // handle first response to an outbound call
    if ($kookoo_action == 'process_outbound_calls') {
      // store kookoo call id for all outbound calls
      $call_id = $_REQUEST['sid'];
      $call->setCallId($call_id);
    }
  }

  // update common call variables
  if (!$call->getCallChannel()) {
    $call->setCallChannel($channel);
  }
  if (!$call->getCallNetwork()) {
    $call->setCallNetwork($network);
  }
  if (!$call->getCallerNumber()) {
    $call->setCallerNumber($_REQUEST['cid_e164']);
  }

  if (!$call->getDestNumber()) {
    $call->setDestNumber($_REQUEST['called_number']);
  }

  //@todo: This parameter is sent when the event is "Dial". It specifies whether the dialed call was answered or unanswered.
  //$kookoo_call_status = $_REQUEST['status'];
  //@todo: check about sms status?
  /*if (empty($kookoo_call_status)) {
    $kookoo_call_status = $_REQUEST['SmsStatus'];
  }*/

  if($_REQUEST['event'] == 'Hangup' || $_REQUEST['event'] == 'Disconnect') {
    $kookoo_call_status = 'completed';
  }
  else if (isset($_REQUEST['status'])) {
    //If the event is "Dial". It specifies whether the dialed call was answered or unanswered.
    //If the event is outbound. It specifies 'answered/ring/invalid_number/busy/network_congestion/exception'
    $kookoo_call_status = $_REQUEST['status'];
  }
  else {
    $kookoo_call_status = 'in-progress';
  }

  // set start time for the call
  if ($kookoo_call_status == 'in-progress') {
    $start_time = $call->getStartTime();
    if (!$start_time) {
      // start counting the call duration
      $call->setStartTime();
    }
  }

  // update call status
  // NOTE: sms callbacks do not have a call status associated with them
  // NOTE: when the user hangs up during a recording, KooKoo sends the record
  // response with the recording data AND CallStatus set to 'completed'. Once that is done,
  // KooKoo calls our process_hangup url to inform, once again, that the call has been hanged.

  if ($kookoo_action == 'process_sms_callback'
        || $kookoo_action == 'process_inbound_text'
        || $kookoo_action == 'process_sms_framework'
        || $kookoo_action == 'process_send_sms'
        || $kookoo_action == 'process_record'
        || $kookoo_action == 'process_record_mp3'
        || $kookoo_action == 'process_empty_recording'
        || $kookoo_action == 'process_wait'
  ) {
    $call->SetCallStatus(VoipCall::IN_PROGRESS);
  }
  else {
    $call = voipkookoo_update_call_status($call, $kookoo_call_status);
  }

  // save the call and initialize its script before setting internal variables
  $call->save();

  // update script variables

  // set text channel variables
  if (strtolower($channel) == 'text') {
    $call->setTextVariables($_REQUEST['message'], $_REQUEST['cid'], '', $network);
  }

  $is_hangup = $call->isHangup();

  // process responses to requests previously-issued by the call script
  if (!$is_hangup) {
    switch ($kookoo_action) {
      default:
        $msg = 'Invalid kookoo_action: @action';
        $params = array('action' => $kookoo_action);
        $call->report_error('voipkookoo', $msg, $params);
        return FALSE;
        break;
      case 'process_inbound_calls':
      case 'process_outbound_calls':
      case 'process_hangup':
      case 'process_inbound_text':
      case 'process_sms_framework':
      case 'process_wait':
        // nothing special to be done here. the above commands have already
        // been processed in the previous lines
        break;
      case 'process_conference':
        // NOTE: in KooKoo, conference calls are executed via the dial command
//       and, therefore, should be processed in the same way
      case 'process_dial':
        $call = _voipkookoo_process_dial_response($call, $_REQUEST);
        break;
      case 'process_get_input':
        $script = $call->getScript();
        //@todo: how to handle no_input in kookoo?
        $input = ($_REQUEST['data'] == 'no_input')
                 ? '' :  $_REQUEST['data'];
        $script->setVar('input_digits', $input);
        $call->setScript($script);
        break;
      case 'process_record':
        $script = $call->getScript();
        if($_REQUEST['status'] == 'silence') {
          //empty recording
          $script->setVar('recording_path', '');
          $script->setVar('recording_public_url', '');
          $script->setVar('recording_duration', 0);
          $script->setVar('recording_digits', NULL);
          $script->setVar('recording_fid', NULL);
        }
        else {
          $kookoo_record_url = $_REQUEST['data'];
          $script->setVar('recording_public_url', $kookoo_record_url);
          $script->setVar('recording_duration', $_REQUEST['record_duration']);

          // NOTE: unlike other providers, KooKoo does not return the digit pressed
          //$script->setVar('recording_digits', $_REQUEST['Digits']);
        }
        $call->setScript($script);
        break;

    //@todo: currently we don't have sms
      case 'process_send_sms':
      case 'process_sms_callback':
        $call = _voipkookoo_process_sms_response($call, $_REQUEST);
        if (strtolower($call->getCallChannel()) == 'text') {
          $call->setEndTime();
          // update sms status
          $call->save();
          // since 'process_sms_callback' is asynchronous, go back
          if ($kookoo_action == 'process_sms_callback') {
            return;
          }
        }
        break;
    }
  }

  if ($is_hangup) {
    //In case of hangup during recording Kookoo will send recording
    //information in this event
    if($_REQUEST['process'] == 'record') {
      $script = $call->getScript();
      //@todo: disabled saving the prompts as it takes >30sec to download which will cause timeout
      $kookoo_record_url = $_REQUEST['data'];
      $script->setVar('recording_path', $kookoo_record_url);
      $script->setVar('recording_public_url', $kookoo_record_url);
      $script->setVar('recording_duration', $_REQUEST['record_duration']);
      $call->setScript($script);
    }
    // determine call duration
    $end_time = $call->setEndTime();
    $start_time = $call->getStartTime();

    if ($call->getDirection() == VoipCall::OUTBOUND) {
      //For outbound calls get duration from Kookoo
      $duration = isset($_REQUEST['duration']) ? $_REQUEST['duration'] : NULL;
    }
    else {
      // get call duration from KooKoo
      $duration = isset($_REQUEST['total_call_duration']) ? $_REQUEST['total_call_duration'] : NULL;
    }
    if(!isset($duration) && $start_time) {
      $duration  = $end_time - $start_time;
    }

    $call->setDuration($duration);
  }

  // update the voipcall with the new values
  $call = $call->save();

  // update the call session object
  $cid = $call->getCid();
  if (!$voip_session->getCid()) {
    $voip_session->setCid($cid);
  }
  $voip_session->resetTimer();
  $voip_session->save();

  // get ready to process the call script

  // load global $user based on call user
  global $user;
  $stored_user = $user;
  $call->loadGlobalUser();
  if (voip_debug()) {
    watchdog('voipkookoo', 'Logged user %uid in.', array('%uid' => $user->uid));
  }

  if ($kookoo_action == 'process_inbound_text') {
    $script = $call->getScript();
    $text_handler = $script->getVar('text_handler');
    $text_handler = !empty($text_handler) ? $text_handler : variable_get('voipcall_default_text_handler', '');

    if ($text_handler) {
      //Execute text_handler
      $continue_processing = call_user_func_array($text_handler,
        array(&$call));
      if(!$continue_processing) {
        return;
      }
    }
    else if (!(strtolower($call->getCallChannel()) == 'text')) {
      //If its not text channel then return
      return;
    }
  }

  // process the call script
  $rc = _voipkookoo_script_handler($call);

  // If global user has been replaced for call user.
  // Process shouldn't go further, so just for good practice.
  if(! empty($stored_user)) {
    $user = $stored_user;
    if (voip_debug()) {
      watchdog('voipkookoo', 'Reverted to logged in user %uid', array('%uid' => $user->uid));
    }
  }

  return; // NOTE: this function MUST NOT return any value.  If it does, the
//       output to KooKoo will get messed up with Drupal hmtl...
}

/**
 * Process voipcall scripts
 *
 * @param $call, VoipCall instance with the call information
 *
 * @return boolean.  TRUE on success or FALSE on failure.  Check voip_error() for processing failure.
 */
function _voipkookoo_script_handler($call) {
  if (voip_debug()) {
    $msg = 'Entering script_handler with voipcall: ' . print_r($call, TRUE);
    watchdog('voipkookoo', $msg, array(), WATCHDOG_INFO);
  }

  $rc = TRUE;

  // get the script object associated with the call
  $script = $call->getScript();

  // check if call is in a hangup state
  $is_hangup = $call->isHangup();
  if ($is_hangup) {
    voipcall_process_hangup($call);
    return TRUE;
  }

  // process script commands
  $processing = TRUE;
  $response = '';
  while ($processing) {
    $cmd = $script->getNextCommand();
    if (!$cmd) {
      $processing = FALSE;

      // no more commands to be processed
      $stack_level = $script->getStackLevel();
      if ($stack_level > 0) {
        //return to previous stack
        $script->runReturn();
        $processing = TRUE;
      }
      else {
        if ($call->getCallChannel() != 'text') {
          // for voice channel send a final hangup request
            $response .= '<Hangup/>';
            $msg = 'Script @name ended without a "hangup" command.';
            $params = array('@name' => $script->getName());
            watchdog('voipkookoo', $msg, $params, WATCHDOG_WARNING);
            $call->setHangupReason(VoipCall::HANGUP_SCRIPT_END);
        }
      }
      //for text channel don't do anything
    }

    // process current command
    else {
      $cmd_id = $cmd->getId();

      switch ($cmd_id) {
        default:
          $msg = "Invalid command id '@cmd_id' in script '@script_name': @script";
          $params = array(
            '@cmd_id' => $cmd_id,
            '@script_name' => $script->getName(),
            '@script' => print_r($script, true),
          );
          $call->report_error('voipkookoo', $msg, $params);
          $rc = FALSE;
          $processing = FALSE;
          break;

        case 'VoipCmdBeep':
          $beep_url = url('voip/sound/beep', array('absolute' => TRUE));
          $response .= "<playaudio>$beep_url</playaudio>";
          break;

        case 'VoipCmdDial':
          $call->setCallStatus(VoipCall::IN_PROGRESS);
          $number = $script->evalString($cmd->getParam('number'));
          if (strtolower($call->getCallChannel()) == 'text') {
            //In case VoipCmdDial is called within text channel then instead of transfer we call the sender.
            //we are starting a call, hangup() the existing session
            $response .= '<hangup></hangup>';

            if (!$number) {
              $number = $call->getCallerNumber();
            }
            $caller_number = variable_get('voipcall_cid_number', NULL);
            $call->setDestNumber($number);
            $call->setCallerNumber($caller_number);
            $call->setScript($script);
            $call->save();
            voip_dial($call);
            $processing = FALSE;
          }
          else {
            //@todo: no action attr how do we get response?
            //$menu_path = 'voip/kookoo/callhandler';
            //$cid = $call->getCid();
            //$response_url = $menu_path . '/process_dial/' . $cid;
            //$action = url($response_url, array('absolute' => TRUE));
            // $method = 'POST';

            $timeout = $script->evalString($cmd->getParam('timeout', 30))*1000; //ms
            //$hangup_on_star =  $script->evalString($cmd->getParam('hangup_on_star', false));
            //$hangup_on_star =  $hangup_on_star ? 'true' : 'false';
            $time_limit = $script->evalString($cmd->getParam('time_limit', '14400')); //@todo is this also in ms?
            $caller_number = $script->evalString($script->getVar('caller_number'));
            $caller_id = $script->evalString($cmd->getParam('caller_id', $caller_number));
            $response .= '<dial timeout="' . $timeout
                            . '" limittime="' . $time_limit
                            . '" caller_id="' . $caller_id
                            . '" >';
            $response .=  $number;
            $response .= '</dial>';
          }

          $rc = TRUE;
          $processing = FALSE;
          break;

        case 'VoipCmdGetInput':
          $call->setCallStatus(VoipCall::IN_PROGRESS);
          //$menu_path = 'voip/kookoo/callhandler';
          //$cid = $call->getCid();
          //$response_url = $menu_path . '/process_get_input/' . $cid;
          //$action = url($response_url, array('absolute' => TRUE));
          //$method = 'POST';
          $timeout = $script->evalString($cmd->getParam('timeout', 5)) * 1000; //KooKoo timeout is in ms
          $end_key = $script->evalString($cmd->getParam('end_key', ''));
          $num_digits = $script->evalString($cmd->getParam('num_digits'));
          $prompt = $cmd->getParam('prompt');
          $response .= '<collectdtmf o="' . $timeout
                            . '" t="' . $end_key;
          if ($num_digits) {
            $response .=      '" l="' . $num_digits;
          }
          $response .= '" >';
          if ($prompt) {
            $response .=  _voipkookoo_generate_audio_response($script, $prompt);
          }
          $response .= '</collectdtmf>';
          //@todo: no redirect method in voip kookoo
          // in case of timeout or empty input, set Digits to 'no_input'
          /*$action_timeout = $action . '&amp;Digits=' . 'no_input';
          $response .= '<Redirect method="GET">'
                         . $action_timeout
                         . '</Redirect>';*/
          $rc = TRUE;
          $processing = FALSE;
          break;

        case 'VoipCmdGosub':
          $script_name = $script->evalString($cmd->getParam('script_name'));
          $options = $script->evalString($cmd->getParam('options'));
          $rc = $script->runGosub($script_name, $options);
          if ($script->isError()) {
            $msg = $script->getErrorMessage();
            $params = array();
            $call->report_error('voipkookoo', $msg, $params);
            $rc = FALSE;
            $processing = FALSE;
            $found = TRUE;
            $text = 'Processing error. Please contact your system administrator.';
            $langcode = $script->getLanguage();
            $text = t($text, NULL, array('langcode' => $langcode));
            $response .= "<playtext>$text</playtext>";
          }
          break;

        case 'VoipCmdGoto':
          $label_name = $script->evalString($cmd->getParam('label_name', ''));
          $rc = $script->runGoto($label_name);
          if ($script->isError()) {
            $msg = $script->getErrorMessage();
            $params = array();
            $call->report_error('voipkookoo', $msg, $params);
            $rc = FALSE;
            $processing = FALSE;
            $found = TRUE;
            $text = 'Processing error. Please contact your system administrator.';
            $langcode = $script->getLanguage();
            $text = t($text, NULL, array('langcode' => $langcode));
            $response .= "<playtext>$text</playtext>";
          }
          break;

        case 'VoipCmdGotoIf':
          $condition = $script->evalString($cmd->getParam('condition', ''));
          if ($condition) {
            $label_name = $script->evalString($cmd->getParam('label_name', ''));
            $rc = $script->runGoto($label_name, $condition);
            if ($script->isError()) {
              $msg = $script->getErrorMessage();
              $params = array();
              $call->report_error('voipkookoo', $msg, $params);
              $rc = FALSE;
              $processing = FALSE;
              $found = TRUE;
              $text = 'Processing error. Please contact your system administrator.';
              $langcode = $script->getLanguage();
              $text = t($text, NULL, array('langcode' => $langcode));
              $response .= "<playtext>$text</playtext>";
            }
          }
          break;

        case 'VoipCmdHangup':
          $call->setCallStatus(VoipCall::IN_PROGRESS);
          $call->setHangupReason(VoipCall::HANGUP_SCRIPT_COMMAND);

          $hangup_mode = $script->evalString($cmd->getParam('hangup_mode'));

          switch ($hangup_mode) {
            case 'resume':
              if ($call->getCallChannel() != 'text') {
                // send the hangup request and stop processing script commands
                // Note: this will trigger a response from KooKoo with $kookoo_action = process_hangup and CallStatus = completed
                $response .= '<hangup></hangup>';
              }
              break;
            case 'reset':
              //Reset script
              $script->resetIndex();
              break;
            case 'end_session':
              //Kill the session if any
              $cid = $call->getCid();
              $session = VoipSession::getSessionByCid($cid);
              if ($session) {
                $session->destroy();
              }

              if ($call->getCallChannel() != 'text') {
                // send the hangup request and stop processing script commands
                // Note: this will trigger a response from KooKoo with $kookoo_action = process_hangup and CallStatus = completed
                $response .= '<hangup></hangup>';
              }
              break;
          }

          $processing = FALSE;
          break;

        case 'VoipCmdJoinConference':
          $call->setCallStatus(VoipCall::IN_PROGRESS);
          /*$menu_path = 'voip/kookoo/callhandler';
          $cid = $call->getCid();
          $response_url = $menu_path . '/process_conference/' . $cid;
          $action = url($response_url, array('absolute' => TRUE));
          $method = 'POST';*/

          /*$muted =  $script->evalString($cmd->getParam('muted', false));
          $muted =  $muted ? 'true' : 'false';
          $beep =  'true'; // by default, announce new participants
          $start_on_enter =  'true';
          $end_on_exit =  'false';
          $wait_url = '';
          $hangup_on_star =  $script->evalString($cmd->getParam('hangup_on_star', false));
          $hangup_on_star =  $hangup_on_star ? 'true' : 'false';
          $time_limit = '14400'; // max allowed for KooKoo calls*/
          /*$response .= '<Dial action="' . $action
                            . '" method="' . $method
                            . '" hangupOnStar="' . $hangup_on_star
                            . '" timeLimit="' . $time_limit
                            . '" >';*/

          $room = $script->evalString($cmd->getParam('room'));
          $response .= '<conference>';
          $response .= $room;
          $response .= '</conference>';
          //$response .= '</Dial>';
          $rc = TRUE;
          $processing = FALSE;
          break;

        case 'VoipCmdLabel':
          // don't do anything. Labels are just placeholders that mark a position within the script.
          break;

        case 'VoipCmdLog':
          $input = $script->evalString($cmd->getParam('input', ''));
          $name = $script->evalString($cmd->getParam('name', NULL));
          $script->runLog($input, $name);
          break;

        case 'VoipCmdRecord':
          $call->setCallStatus(VoipCall::IN_PROGRESS);
          //$menu_path = 'voip/kookoo/callhandler';
          //$cid = $call->getCid();
          //@todo: other formats are coming soon http://www.kookoo.in/index.php/kookoo-docs#record
          //$format = $script->evalString($cmd->getParam('format'));
          $format = 'wav';
          /*if ($format == 'mp3') {
            $response_url = $menu_path . '/process_record_mp3/' . $cid;
          }
          else {
            // return wav file
            $response_url = $menu_path . '/process_record/' . $cid;
          }*/
          //$action = url($response_url, array('absolute' => TRUE));
          //$method = 'POST';
          $prompt = $cmd->getParam('prompt', '');
          $timeout = $script->evalString($cmd->getParam('timeout', 5));
          //$end_key = $script->evalString($cmd->getParam('end_key', '#'));
          $max_length = $script->evalString($cmd->getParam('max_length', 3600));
          //$play_beep = $script->evalString($cmd->getParam('play_beep'));
          //$play_beep = $play_beep ? 'true' : 'false';
          //@todo: play mp3 beep instead
          if ($prompt) {
            $response .= _voipkookoo_generate_audio_response($script, $prompt);
          }
          $filename = time();

          $response .= '<record format="' . $format
                            //. '" silence="' . $timeout
                            //. '" maxduration="' . $max_length
                            . '">'.$filename.'</record>';
          //@todo: how to handle empty recording?
          // in case of empty recording...
          /*$response_url = $menu_path . '/process_empty_recording/' . $cid;
          $action = url($response_url, array('absolute' => TRUE));
          $response .= '<Redirect method="GET">'
                         . $action
                         . '</Redirect>';*/
          $rc = TRUE;
          $processing = FALSE;
          break;

        //@todo: there is no reject in VoIP KooKoo
        /*case 'VoipCmdReject':
          $call->setHangupReason(VoipCall::HANGUP_REJECTED);
          $reason_tmp = $script->evalString($cmd->getParam('reason'));
          $reason =
            ($reason_tmp == VoipScript::REJECT_BUSY) ? 'busy' : 'rejected';
          $response .= "<Reject reason='$reason' />";
          $rc = TRUE;
          $processing = FALSE;
          break;*/

        case 'VoipCmdReturn':
          $rc = $script->runReturn();
          if ($script->isError()) {
            $msg = $script->getErrorMessage();
            $params = array();
            $call->report_error('voipkookoo', $msg, $params);
            $rc = FALSE;
            $processing = FALSE;
            $found = TRUE;
            // report the error to the phone user

            $voice_id = $script->getVoice();
            //KooKoo uses gender instead of voice id
            $voice = VoipVoice::getVoice($voice_id);
            $voice_id = _voipkookoo_get_kookoo_voice_id($voice_id);
            //$gender = $voice->getGender();
            $language = $voice->getLanguage();
            $text = 'Processing error. Please contact your system administrator.';
            // translate the text
            $text = t($text, NULL, array('langcode' => $language));
            //@todo: wait for KooKoo to introduce voices
            //$response .= "<Say voice='$gender' language='$language'>$text</Say>";
            $response .= "<playtext lang='$voice_id'>$text</playtext>";
          }
          break;

        case 'VoipCmdRunIvrMenu':
          $options['prompt'] = $cmd->getParam('prompt');
          $options['input_options'] =
            $script->evalString($cmd->getParam('input_options'));
          $options['invalid_msg'] = $cmd->getParam('invalid_msg');
          $options['no_input_msg'] = $cmd->getParam('no_input_msg');
          $options['max_attempts'] =
            $script->evalString($cmd->getParam('max_attempts'));
          $options['timeout'] = $script->evalString($cmd->getParam('timeout'));
          $rc = $script->runIvrMenu($options);
          break;

        case 'VoipCmdSay':
          $call->setCallStatus(VoipCall::IN_PROGRESS);
          $prompt = $cmd->getParam('prompt');
          $loop = $script->evalString($cmd->getParam('loop'));
          $response .=
            _voipkookoo_generate_audio_response($script, $prompt, $loop);
          break;

        case 'VoipCmdSayAs':
          $server = VoipServer::getServer('kookoo');
          $server_config = $server->getConfig();
          $say_as_voice = $server_config['voipcall_sayas_voice_id'];
          $call->setCallStatus(VoipCall::IN_PROGRESS);
          $prompt = $cmd->getParam('prompt');
          $format = $script->evalString($cmd->getParam('format'));
          $voice_id = $script->evalString($cmd->getParam('voice'));
          $voice_id = !empty($voice_id) ? $voice_id : $say_as_voice;
          switch($format) {
            case 'date':
              $format_code = 202;
              break;
            case 'number':
              $format_code = 1;
              break;
            case 'digit':
              $format_code = 501;
              break;
            case 'currency':
              $format_code = 402;
              break;

          }
          $response .= '<say-as format="'.$format_code.'" lang="'.$voice_id.'">'.$prompt.'</say-as>';
          break;

        case 'VoipCmdSendText':
          $call->setCallStatus(VoipCall::IN_PROGRESS);
          $to = $script->evalString($cmd->getParam('to'));
          $text = $script->evalString($cmd->getParam('text'));
          $network = $script->evalString($cmd->getParam('network'));
          $sms_origin = $call->getCallOrigin();
          // If "to" is empty then send message to the person on the other
          // side of the phone. Depending on the direction of the call, that
          // might be either the caller or the callee.
          if (!$to) {
            $direction = $call->getDirection();
            if ($direction == 'inbound') {
              $to = $script->evalString($script->getVar('caller_number'));
              $from = $script->evalString($script->getVar('dest_number'));
            }
            else {
              $to = $script->evalString($script->getVar('dest_number'));
              $from = $script->evalString($script->getVar('caller_number'));
            }
            if (!$to) {
              watchdog('voipkookoo', 'Attempt to send '.$network.' to empty number', array(), WATCHDOG_ERROR);
              $processing = TRUE;
              break;
            }
          }
          if (voipscript_use_sms_framework()) {
            // Use SMS Framework to send SMS message if user enabled this option
            voipscript_send_sms_framework($to, $text);
          }
          else if($sms_origin == 'smsframework'){
            //Use voip_text()
            $reply = TRUE;
            //We must unset dest_number because it will be number of SMS Framework gateway
            $call->setDestNumber('');
            $call = $call->save();
            voip_text($text, $call, $reply);
            $processing = TRUE;
          }
          else {
            if(!$from) {
              // Note: If no caller number provided, KooKoo will automatically try
              //       to determine an appropriate value depending on whether the
              //       call is inbound or outbound. However, since that number might
              //       not be sms capable, it might incur in a processing error.
              // Use the system's number as the default caller id
              $default_cid_number = variable_get('voipcall_cid_number', NULL);
              $from = $script->evalString($cmd->getParam('caller_id',
                $default_cid_number));
            }

            $rc = TRUE;
            switch(strtolower($network)){
              default:
                $params = array('@network' => $network,
                                '@script_name' => $script->getName(),
                                '@script' => print_r($script,true));
                $msg = "Invalid 'network' parameter '@network' for SendText command in script '@script_name': @script";
                $call->report_error('voipkookoo', $msg, $params);
                $rc = FALSE;
                $processing = FALSE;
                break;

              case 'sms':
                $response .= '<sendsms to="' . $to.'">';
				        // replace special chars for their html equivalent
                $response .= htmlspecialchars($text, ENT_NOQUOTES | ENT_HTML401);
                $response .= '</sendsms>';
                break;
            }
          }
          break;

        case 'VoipCmdSet':
          $var_name = $script->evalString($cmd->getParam('var_name'));
          $var_value = $script->evalString($cmd->getParam('var_value'));
          $script->setVar($var_name, $var_value);
          break;

        case 'VoipCmdSetVoice':
          $voice_id = $script->evalString($cmd->getParam('voice'));
          $voice = VoipVoice::getVoice($voice_id);
          $voice_id = $voice->getVoiceId();
          $script->setVoice($voice_id);
          break;

        case 'VoipCmdUnset':
          $var_name = $script->evalString($cmd->getParam('var_name'));
          $script->unsetVar($var_name);
          break;

        case 'VoipCmdWait':
          $channel = $call->getCallChannel();
          if ($channel != 'voice') {
            watchdog('voipkookoo', 'Attempt to call addWait() command in SMS message.', array(), WATCHDOG_ERROR);
            $processing = TRUE;
            break;
          }
          $time_limit = $script->evalString($cmd->getParam('time_limit')) / 0.55; //Looks like one period matches 0.55sec.
          //@todo: check if Equivalent of the wait function?:
          for ($i = 0; $i < $time_limit; $i++) {
            $periods .= ". ";
          }
          $response .= '<playtext>'.$periods.'</playtext>';
          $processing = FALSE;
          break;

      }

      // go to next command
    }
  }

  // save script for next iteration
  $call->setScript($script);
  $call->save();

  // send response back to KooKoo
  if ($response) {

    //$response .= '<!--' . "_REQUEST: " . print_r($_REQUEST,true) .  "\n" . '-->';
    //$response .= '<!--' . "voipcall: " . print_r($call,true) .  "\n" . '-->';

    _voipkookoo_send_response($response);
  }

  return $rc;
}

/**
 * Send responses to KooKoo
 */
function _voipkookoo_send_response($response) {
  $output = '<?xml version="1.0" encoding="UTF-8" ?>';
  $output .= '<response>';
  $output .= $response;
  $output .= '</response>';

  drupal_add_http_header('Content-Type', 'text/xml; charset=utf-8');
  print $output;

  return TRUE;
}


/**
 * Update 'call status' and 'hangup reason' based on KooKoo's response
 */
function voipkookoo_update_call_status($call, $kookoo_call_status = 'in-progress') {
  switch ($kookoo_call_status) {
    default:
      $msg = 'Invalid CallStatus: @status for call cid: @cid';
      $cid = $call->getCid();
      $params = array(
        '@status' => $kookoo_call_status,
        '@cid' => $cid,
      );
      $call->report_error('voipkookoo', $msg, $params);
      break;
    case 'invalid_number': // call failed, most likely due to invalid number
      $call->setCallStatus(VoipCall::INVALID);
      $call->setHangupReason(VoipCall::HANGUP_INVALID_NUMBER);
      break;
    case 'queued':
      $call->setCallStatus(VoipCall::QUEUED);
      break;
    case 'ring':
      $call->setCallStatus(VoipCall::RINGING);
      break;
    case 'in-progress':
    case 'answered':
      $call->setCallStatus(VoipCall::IN_PROGRESS);
      break;
    case 'completed':
    case 'success':
      $call->setCallStatus(VoipCall::COMPLETED);
      $hangup_reason = $call->getHangupReason();
      if (!$hangup_reason) {
        $call->setHangupReason(VoipCall::HANGUP_BY_USER);
      }
      break;
    case 'busy':
      $call->setCallStatus(VoipCall::BUSY);
      $call->setHangupReason(VoipCall::HANGUP_BUSY);
      break;
    case 'network_congestion':
    case 'exception':
      $call->setCallStatus(VoipCall::NO_ANSWER);
      $call->setHangupReason(VoipCall::HANGUP_NO_ANSWER);
      break;
    /*case 'canceled':
      $call->setCallStatus(VoipCall::CANCELED);
      $call->setHangupReason(VoipCall::HANGUP_API_REQUEST);
      break;*/
  }
  return $call;
}


/**
 * Process the response to a "dial" script command
 */
function _voipkookoo_process_dial_response($call, $request) {
  $script = $call->getScript();

  //@todo: how to get sid of dialed number?
  // update the 'dial_sid' script variable
  //$script->setVar('dial_sid', $request['DialCallSid']);

  // update the 'dial_status' script variable
  $dial_status = $request['status'];
  switch ($dial_status) {
    default:
      $cid = $call->getCid();
      $msg = 'Invalid DialCallStatus: @status for call cid: @cid';
      $params = array(
        '@status' => $dial_status,
        '@cid' => $cid,
      );
      $call->report_error('voipkookoo', $msg, $params);
      return NULL;
      break;
    case 'answered':
      $script->setVar('dial_status', VoipScript::DIAL_COMPLETED);
      break;
    case 'not_answered':
      $script->setVar('dial_status', VoipScript::DIAL_NO_ANSWER);
      break;
  }

  // update the 'dial_duration' script variable
  $duration = $request['duration']; //This parameter is sent when the event is either "Record" or "Dial". It specifies the amount of time the recording or dial happened.
  if (isset($duration)) {
    $script->setVar('dial_duration', $duration);
  }

  $call->setScript($script);
  return $call;
}

/**
 * Process the response to a 'send text' script command
 */
function _voipkookoo_process_sms_response($call, $request) {
  $cid = $call->getCid();
  $sms_status_tmp = $request['SmsStatus'];
  switch ($sms_status_tmp) {
    default:
      $msg = 'Invalid SmsStatus: @status for call cid: @cid';
      $params = array(
        '@status' => $sms_status_tmp,
        '@cid' => $cid,
      );
      $call->report_error('voipkookoo', $msg, $params);
      return NULL;
      break;
    case 'failed':
      $msg = 'SMS sending failed for call cid: @cid. Make sure your KooKoo number is sms-enabled.';
      $params = array('@cid' => $cid);
      watchdog('voipkookoo', $msg, $params, WATCHDOG_WARNING);
      $text_status = VoipCall::TEXT_FAILED;
      break;
    case 'invalid':
      $msg = 'Invalid SMS parameter for call cid: @cid';
      $params = array('@cid' => $cid);
      watchdog('voipkookoo', $msg, $params, WATCHDOG_WARNING);
      $text_status = VoipCall::TEXT_INVALID;
      break;
    case 'sending':
      $text_status = VoipCall::TEXT_SENDING;
      break;
    case 'received': // TODO: this is status is not documented in kookoo.com. is this a kookoo bug?
    case 'sent':
      $text_status = VoipCall::TEXT_SENT;
      break;
  }
  $call->setTextStatus($text_status);
//TODO: deprecate send_text_status and replace it by %text_status, which is already updated by voicall together w/ other script variables
  $script = $call->getScript();
  $script->setVar('send_text_status', $text_status);
  $call->setScript($script);
  return $call;
}

define('VOIPKOOKOO_URL_CHECK', '#(https?://\S+(?<![,.;?\:\!]))#');

/**
 * Generate a prompt to be played to the user
 *
 * @param $script
 *   The VoipScript instance being executed
 *
 * @param $prompt
 *   Mixed. Can be any of the following
 *   - an executable string to be processed into a prompt string, a VoipPrompt
 *     instance, or an array of VoipPrompt instances
 *   - a prompt string to played to the user
 *   - an array of VoipPrompt instances to be processed
 *
 * @param $loop
 *   Integer with the number of times to repeat the prompt
 *
 * @return
 *   The prompt as a KooKooML sequence to be sent to KooKoo
 */
function _voipkookoo_generate_audio_response($script, $prompt, $loop = 1) {
  $server = VoipServer::getServer('kookoo');
  $server_config = $server->getConfig();
  $voipcall_sayas_enabled = $server_config['voipcall_sayas_enabled'];
  //$say_as_voice = $server_config['voipcall_sayas_voice_id'];
  $response = '';
  if (is_string($prompt) && (substr($prompt, 0, 1) == '^')) {
    $prompt = $script->evalString($prompt);
  }

  if (is_string($prompt)) {
    $prompt_list[] = new VoipPrompt($prompt);
  }
  else if (is_object($prompt)) {
    $prompt_list[] = $prompt;
  }
  else {
    $prompt_list = $prompt;
  }

  $default_voice_id = $script->getVoice();

  foreach ($prompt_list as $p) {
    $text = $script->evalString($p->getText());
    $voice_id = $p->getVoice() ? $p->getVoice() : $default_voice_id;
    $voice = VoipVoice::getVoice($voice_id);
    $voice_id = _voipkookoo_get_kookoo_voice_id($voice_id);
    //$gender = $voice->getGender();
    //$language = $voice->getLanguage();

    $as_tmp = $p->getAs() ? $p->getAs() : '';
    $as = $as_tmp ? $as_tmp : 'number';

    // split the text into audio URLs and text elements
    $elements =
      preg_split(VOIPKOOKOO_URL_CHECK, $text, -1, PREG_SPLIT_DELIM_CAPTURE);

    // process each element
    $url_flag = FALSE;
    foreach ($elements as $element) {
      $element = trim($element);
      if ($element) {
        if (_voipkookoo_is_url($element)) {
          $response .= "<playaudio>$element</playaudio>";
          $url_flag = TRUE;
        }
        else {
          if ($url_flag) {
            // remove punctuation associated with the previous url element
            // i.e. the '!' in $text = 'Hello $audio_name!"
            $element = ltrim($element, '?!.;,:');
            $url_flag = FALSE;
          }
          if ($element) {
            if ($as == 'digits') {
              //Convert numbers into digits
              $element = _voipkookoo_parse_digits($element);
            }
            else if($as == 'number') {
              if ($voipcall_sayas_enabled) {
                $element = _voipkookoo_parse_numbers($element);
              }
            }
            //$response .= "<Say voice='$gender' language='$language'>$element</Say>";
            //@todo: VoIP KooKoo:Very soon we will add attributes to this tag to allow you choose the language, TTS engine as well as male or female voice.
            $response .= "<playtext lang='".$voice_id."'>$element</playtext>";
          }
        }
      }
    }
  }

  // process the $loop parameter
  $counter = $loop - 1;
  while ($counter > 0) {
    $response .= $response;
    $counter--;
  }

  return $response;
}


/**
 * Check if the given string is a url
 */
function _voipkookoo_is_url($str) {
  // Note: Although the checking performed is not as complete as
//       http://stackoverflow.com/questions/161738/what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url , it seems to serve our purposes!
  $rc = preg_match(VOIPKOOKOO_URL_CHECK, $str);
  return $rc;
}

function _voipkookoo_parse_numbers($str) {
  //preg_match_all("{(\d+)}", $str, $result, PREG_PATTERN_ORDER);
  //return $result;
  return preg_replace_callback('{(\d+)}', '_voipkookoo_numbers_callback', $str);
}

function _voipkookoo_numbers_callback($matches) {
  $server = VoipServer::getServer('kookoo');
  $server_config = $server->getConfig();
  $say_as_voice = $server_config['voipcall_sayas_voice_id'];
  //@todo: language is hardcoded. Fix when Kookoo introduces more languages
  $ret = '</playtext><say-as format="1" lang="'.$say_as_voice.'">'.$matches[0].'</say-as><playtext lang="EN">';
  return $ret;
}

function _voipkookoo_parse_digits($str) {
  //preg_match_all("{(\d+)}", $str, $result, PREG_PATTERN_ORDER);
  //return $result;
  return preg_replace_callback('{(\d+)}', '_voipkookoo_digits_add_space', $str);
}

function _voipkookoo_digits_add_space($matches) {
  $server = VoipServer::getServer('kookoo');
  $server_config = $server->getConfig();
  $voipcall_sayas_enabled = $server_config['voipcall_sayas_enabled'];
  $say_as_voice = $server_config['voipcall_sayas_voice_id'];


  if ($voipcall_sayas_enabled) {
    //@todo: language is hardcoded. Fix when Kookoo introduces more languages
    $ret = '</playtext><say-as format="501" lang="'.$say_as_voice.'">'.$matches[0].'</say-as><playtext lang="EN">';
  }
  else {
    $string_array = str_split($matches[0]);
    $number_with_space = implode(" ", $string_array);
    $ret = $number_with_space;
  }
  return $ret;
}

//Get safe voice Tropo
function _voipkookoo_get_kookoo_voice_id($voice_id) {
  //we need to get safe voice id
  $server = VoipServer::getServer('kookoo');
  $tropo_voices = $server->_get_available_voices();
  if (!isset($tropo_voices[$voice_id])) {
    $voice = VoipVoice::getVoice($voice_id);
    $gender = $voice->getGender();
    if ($gender == 'man') {
      $voice_id = $server->getDefaultManVoice()->getVoiceId();
    }
    else if ($gender == 'woman') {
      $voice_id = $server->getDefaultWomanVoice()->getVoiceId();
    }
    else {
      $voice_id = $server->getDefaultVoice()->getVoiceId();
    }
  }

  return $voice_id;
}

function _voipkookoo_event_to_actions($event) {
  $events = array(
    'NewCall' => 'process_inbound_calls',
    'Record' => 'process_record',
    'GotDTMF' => 'process_get_input',
    'Hangup' => 'process_hangup',
    //@todo:??
    'Disconnect' => 'process_hangup',
    'Dial' => 'process_dial',
    'NewSms' => 'process_inbound_text',
  );

  return $events[$event];
}
